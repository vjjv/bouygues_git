import Long from 'long';
import { grpc } from '@improbable-eng/grpc-web';
import _m0 from 'protobufjs/minimal';
import { Observable } from 'rxjs';
import { BrowserHeaders } from 'browser-headers';
import { share } from 'rxjs/operators';
import { Lens } from './lens';
export const protobufPackage = 'com.snap.camerakit.v3';
export var PushLensSubscriptionResponse_ExcludedLens_Code;
(function (PushLensSubscriptionResponse_ExcludedLens_Code) {
    PushLensSubscriptionResponse_ExcludedLens_Code["UNSET"] = "UNSET";
    PushLensSubscriptionResponse_ExcludedLens_Code["UNKNOWN"] = "UNKNOWN";
    PushLensSubscriptionResponse_ExcludedLens_Code["NOT_FOUND"] = "NOT_FOUND";
    PushLensSubscriptionResponse_ExcludedLens_Code["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
    PushLensSubscriptionResponse_ExcludedLens_Code["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
    PushLensSubscriptionResponse_ExcludedLens_Code["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
    PushLensSubscriptionResponse_ExcludedLens_Code["UNRECOGNIZED"] = "UNRECOGNIZED";
})(PushLensSubscriptionResponse_ExcludedLens_Code || (PushLensSubscriptionResponse_ExcludedLens_Code = {}));
export function pushLensSubscriptionResponse_ExcludedLens_CodeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return PushLensSubscriptionResponse_ExcludedLens_Code.UNSET;
        case 1:
        case "UNKNOWN":
            return PushLensSubscriptionResponse_ExcludedLens_Code.UNKNOWN;
        case 2:
        case "NOT_FOUND":
            return PushLensSubscriptionResponse_ExcludedLens_Code.NOT_FOUND;
        case 3:
        case "INCOMPATIBLE_LENS_CORE_VERSION":
            return PushLensSubscriptionResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION;
        case 4:
        case "ARCHIVED_OR_INVISIBLE":
            return PushLensSubscriptionResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE;
        case 5:
        case "CONTAINS_MUSIC":
            return PushLensSubscriptionResponse_ExcludedLens_Code.CONTAINS_MUSIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PushLensSubscriptionResponse_ExcludedLens_Code.UNRECOGNIZED;
    }
}
export function pushLensSubscriptionResponse_ExcludedLens_CodeToJSON(object) {
    switch (object) {
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNSET: return "UNSET";
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNKNOWN: return "UNKNOWN";
        case PushLensSubscriptionResponse_ExcludedLens_Code.NOT_FOUND: return "NOT_FOUND";
        case PushLensSubscriptionResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION: return "INCOMPATIBLE_LENS_CORE_VERSION";
        case PushLensSubscriptionResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE: return "ARCHIVED_OR_INVISIBLE";
        case PushLensSubscriptionResponse_ExcludedLens_Code.CONTAINS_MUSIC: return "CONTAINS_MUSIC";
        default: return "UNKNOWN";
    }
}
export function pushLensSubscriptionResponse_ExcludedLens_CodeToNumber(object) {
    switch (object) {
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNSET: return 0;
        case PushLensSubscriptionResponse_ExcludedLens_Code.UNKNOWN: return 1;
        case PushLensSubscriptionResponse_ExcludedLens_Code.NOT_FOUND: return 2;
        case PushLensSubscriptionResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION: return 3;
        case PushLensSubscriptionResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE: return 4;
        case PushLensSubscriptionResponse_ExcludedLens_Code.CONTAINS_MUSIC: return 5;
        default: return 0;
    }
}
export var ListenLensPushResponse_ExcludedLens_Code;
(function (ListenLensPushResponse_ExcludedLens_Code) {
    ListenLensPushResponse_ExcludedLens_Code["UNSET"] = "UNSET";
    ListenLensPushResponse_ExcludedLens_Code["UNKNOWN"] = "UNKNOWN";
    ListenLensPushResponse_ExcludedLens_Code["NOT_FOUND"] = "NOT_FOUND";
    ListenLensPushResponse_ExcludedLens_Code["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
    ListenLensPushResponse_ExcludedLens_Code["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
    ListenLensPushResponse_ExcludedLens_Code["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
    ListenLensPushResponse_ExcludedLens_Code["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ListenLensPushResponse_ExcludedLens_Code || (ListenLensPushResponse_ExcludedLens_Code = {}));
export function listenLensPushResponse_ExcludedLens_CodeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return ListenLensPushResponse_ExcludedLens_Code.UNSET;
        case 1:
        case "UNKNOWN":
            return ListenLensPushResponse_ExcludedLens_Code.UNKNOWN;
        case 2:
        case "NOT_FOUND":
            return ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND;
        case 3:
        case "INCOMPATIBLE_LENS_CORE_VERSION":
            return ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION;
        case 4:
        case "ARCHIVED_OR_INVISIBLE":
            return ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE;
        case 5:
        case "CONTAINS_MUSIC":
            return ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ListenLensPushResponse_ExcludedLens_Code.UNRECOGNIZED;
    }
}
export function listenLensPushResponse_ExcludedLens_CodeToJSON(object) {
    switch (object) {
        case ListenLensPushResponse_ExcludedLens_Code.UNSET: return "UNSET";
        case ListenLensPushResponse_ExcludedLens_Code.UNKNOWN: return "UNKNOWN";
        case ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND: return "NOT_FOUND";
        case ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION: return "INCOMPATIBLE_LENS_CORE_VERSION";
        case ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE: return "ARCHIVED_OR_INVISIBLE";
        case ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC: return "CONTAINS_MUSIC";
        default: return "UNKNOWN";
    }
}
export function listenLensPushResponse_ExcludedLens_CodeToNumber(object) {
    switch (object) {
        case ListenLensPushResponse_ExcludedLens_Code.UNSET: return 0;
        case ListenLensPushResponse_ExcludedLens_Code.UNKNOWN: return 1;
        case ListenLensPushResponse_ExcludedLens_Code.NOT_FOUND: return 2;
        case ListenLensPushResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION: return 3;
        case ListenLensPushResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE: return 4;
        case ListenLensPushResponse_ExcludedLens_Code.CONTAINS_MUSIC: return 5;
        default: return 0;
    }
}
function createBasePushLensSubscriptionRequest() {
    return { accountId: "", extensionRequestContext: new Uint8Array(), heartbeat: 0 };
}
export const PushLensSubscriptionRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.accountId !== "") {
            writer.uint32(10).string(message.accountId);
        }
        if (message.extensionRequestContext.length !== 0) {
            writer.uint32(18).bytes(message.extensionRequestContext);
        }
        if (message.heartbeat !== 0) {
            writer.uint32(24).int32(message.heartbeat);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.string();
                    break;
                case 2:
                    message.extensionRequestContext = reader.bytes();
                    break;
                case 3:
                    message.heartbeat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountId: isSet(object.accountId)
                ? String(object.accountId)
                : "",
            extensionRequestContext: isSet(object.extensionRequestContext)
                ? bytesFromBase64(object.extensionRequestContext)
                : new Uint8Array(),
            heartbeat: isSet(object.heartbeat)
                ? Number(object.heartbeat)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.accountId !== undefined && (obj.accountId = message.accountId);
        message.extensionRequestContext !== undefined && (obj.extensionRequestContext = base64FromBytes(message.extensionRequestContext !== undefined ? message.extensionRequestContext : new Uint8Array()));
        message.heartbeat !== undefined && (obj.heartbeat = Math.round(message.heartbeat));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionRequest();
        message.accountId = object.accountId ?? "";
        message.extensionRequestContext = object.extensionRequestContext ?? new Uint8Array();
        message.heartbeat = object.heartbeat ?? 0;
        return message;
    }
};
function createBasePushLensSubscriptionResponse() {
    return { lens: undefined, excludedLens: undefined, heartbeat: 0, lenses: {} };
}
export const PushLensSubscriptionResponse = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lens = Lens.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.excludedLens = PushLensSubscriptionResponse_ExcludedLens.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.heartbeat = reader.int32();
                    break;
                case 4:
                    const entry4 = PushLensSubscriptionResponse_LensesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.lenses[entry4.key] = entry4.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            lens: isSet(object.lens)
                ? Lens.fromJSON(object.lens)
                : undefined,
            excludedLens: isSet(object.excludedLens)
                ? PushLensSubscriptionResponse_ExcludedLens.fromJSON(object.excludedLens)
                : undefined,
            heartbeat: isSet(object.heartbeat)
                ? Number(object.heartbeat)
                : 0,
            lenses: isObject(object.lenses)
                ? Object.entries(object.lenses).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.lens !== undefined && (obj.lens = message.lens ? Lens.toJSON(message.lens) : undefined);
        message.excludedLens !== undefined && (obj.excludedLens = message.excludedLens ? PushLensSubscriptionResponse_ExcludedLens.toJSON(message.excludedLens) : undefined);
        message.heartbeat !== undefined && (obj.heartbeat = Math.round(message.heartbeat));
        obj.lenses = {};
        if (message.lenses) {
            Object.entries(message.lenses).forEach(([k, v]) => {
                obj.lenses[k] = base64FromBytes(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionResponse();
        message.lens = (object.lens !== undefined && object.lens !== null)
            ? Lens.fromPartial(object.lens)
            : undefined;
        message.excludedLens = (object.excludedLens !== undefined && object.excludedLens !== null)
            ? PushLensSubscriptionResponse_ExcludedLens.fromPartial(object.excludedLens)
            : undefined;
        message.heartbeat = object.heartbeat ?? 0;
        message.lenses = Object.entries(object.lenses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    }
};
function createBasePushLensSubscriptionResponse_LensesEntry() {
    return { key: "", value: new Uint8Array() };
}
export const PushLensSubscriptionResponse_LensesEntry = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionResponse_LensesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key)
                ? String(object.key)
                : "",
            value: isSet(object.value)
                ? bytesFromBase64(object.value)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionResponse_LensesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
    }
};
function createBasePushLensSubscriptionResponse_ExcludedLens() {
    return { lensId: 0, code: PushLensSubscriptionResponse_ExcludedLens_Code.UNSET };
}
export const PushLensSubscriptionResponse_ExcludedLens = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushLensSubscriptionResponse_ExcludedLens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lensId = longToNumber(reader.int64());
                    break;
                case 2:
                    message.code = pushLensSubscriptionResponse_ExcludedLens_CodeFromJSON(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            lensId: isSet(object.lensId)
                ? Number(object.lensId)
                : 0,
            code: isSet(object.code)
                ? pushLensSubscriptionResponse_ExcludedLens_CodeFromJSON(object.code)
                : PushLensSubscriptionResponse_ExcludedLens_Code.UNSET,
        };
    },
    toJSON(message) {
        const obj = {};
        message.lensId !== undefined && (obj.lensId = Math.round(message.lensId));
        message.code !== undefined && (obj.code = pushLensSubscriptionResponse_ExcludedLens_CodeToJSON(message.code));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushLensSubscriptionResponse_ExcludedLens();
        message.lensId = object.lensId ?? 0;
        message.code = object.code ?? PushLensSubscriptionResponse_ExcludedLens_Code.UNSET;
        return message;
    }
};
function createBaseListenLensPushRequest() {
    return { extensionRequestContext: new Uint8Array(), heartbeat: 0 };
}
export const ListenLensPushRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.extensionRequestContext.length !== 0) {
            writer.uint32(18).bytes(message.extensionRequestContext);
        }
        if (message.heartbeat !== 0) {
            writer.uint32(24).int32(message.heartbeat);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.extensionRequestContext = reader.bytes();
                    break;
                case 3:
                    message.heartbeat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            extensionRequestContext: isSet(object.extensionRequestContext)
                ? bytesFromBase64(object.extensionRequestContext)
                : new Uint8Array(),
            heartbeat: isSet(object.heartbeat)
                ? Number(object.heartbeat)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.extensionRequestContext !== undefined && (obj.extensionRequestContext = base64FromBytes(message.extensionRequestContext !== undefined ? message.extensionRequestContext : new Uint8Array()));
        message.heartbeat !== undefined && (obj.heartbeat = Math.round(message.heartbeat));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListenLensPushRequest();
        message.extensionRequestContext = object.extensionRequestContext ?? new Uint8Array();
        message.heartbeat = object.heartbeat ?? 0;
        return message;
    }
};
function createBaseListenLensPushResponse() {
    return { excludedLens: undefined, heartbeat: 0, lenses: {} };
}
export const ListenLensPushResponse = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.excludedLens = ListenLensPushResponse_ExcludedLens.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.heartbeat = reader.int32();
                    break;
                case 4:
                    const entry4 = ListenLensPushResponse_LensesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.lenses[entry4.key] = entry4.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            excludedLens: isSet(object.excludedLens)
                ? ListenLensPushResponse_ExcludedLens.fromJSON(object.excludedLens)
                : undefined,
            heartbeat: isSet(object.heartbeat)
                ? Number(object.heartbeat)
                : 0,
            lenses: isObject(object.lenses)
                ? Object.entries(object.lenses).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        message.excludedLens !== undefined && (obj.excludedLens = message.excludedLens ? ListenLensPushResponse_ExcludedLens.toJSON(message.excludedLens) : undefined);
        message.heartbeat !== undefined && (obj.heartbeat = Math.round(message.heartbeat));
        obj.lenses = {};
        if (message.lenses) {
            Object.entries(message.lenses).forEach(([k, v]) => {
                obj.lenses[k] = base64FromBytes(v);
            });
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListenLensPushResponse();
        message.excludedLens = (object.excludedLens !== undefined && object.excludedLens !== null)
            ? ListenLensPushResponse_ExcludedLens.fromPartial(object.excludedLens)
            : undefined;
        message.heartbeat = object.heartbeat ?? 0;
        message.lenses = Object.entries(object.lenses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseListenLensPushResponse_LensesEntry() {
    return { key: "", value: new Uint8Array() };
}
export const ListenLensPushResponse_LensesEntry = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushResponse_LensesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key)
                ? String(object.key)
                : "",
            value: isSet(object.value)
                ? bytesFromBase64(object.value)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListenLensPushResponse_LensesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
    }
};
function createBaseListenLensPushResponse_ExcludedLens() {
    return { lensId: 0, code: ListenLensPushResponse_ExcludedLens_Code.UNSET };
}
export const ListenLensPushResponse_ExcludedLens = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListenLensPushResponse_ExcludedLens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lensId = longToNumber(reader.int64());
                    break;
                case 2:
                    message.code = listenLensPushResponse_ExcludedLens_CodeFromJSON(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            lensId: isSet(object.lensId)
                ? Number(object.lensId)
                : 0,
            code: isSet(object.code)
                ? listenLensPushResponse_ExcludedLens_CodeFromJSON(object.code)
                : ListenLensPushResponse_ExcludedLens_Code.UNSET,
        };
    },
    toJSON(message) {
        const obj = {};
        message.lensId !== undefined && (obj.lensId = Math.round(message.lensId));
        message.code !== undefined && (obj.code = listenLensPushResponse_ExcludedLens_CodeToJSON(message.code));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseListenLensPushResponse_ExcludedLens();
        message.lensId = object.lensId ?? 0;
        message.code = object.code ?? ListenLensPushResponse_ExcludedLens_Code.UNSET;
        return message;
    }
};
export class PushToDeviceClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.PushLensSubscription = this.PushLensSubscription.bind(this);
        this.ListenLensPush = this.ListenLensPush.bind(this);
    }
    PushLensSubscription(request, metadata) {
        return this.rpc.invoke(PushToDevicePushLensSubscriptionDesc, request, metadata);
    }
    ListenLensPush(request, metadata) {
        return this.rpc.invoke(PushToDeviceListenLensPushDesc, ListenLensPushRequest.fromPartial(request), metadata);
    }
}
export const PushToDeviceDesc = {
    serviceName: "com.snap.camerakit.v3.PushToDevice",
};
export const PushToDevicePushLensSubscriptionDesc = {
    methodName: "PushLensSubscription",
    service: PushToDeviceDesc,
    requestStream: false,
    responseStream: true,
    requestType: {
        serializeBinary() {
            return PushLensSubscriptionRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return { ...PushLensSubscriptionResponse.decode(data), toObject() { return this; } };
        }
    },
};
export const PushToDeviceListenLensPushDesc = {
    methodName: "ListenLensPush",
    service: PushToDeviceDesc,
    requestStream: false,
    responseStream: true,
    requestType: {
        serializeBinary() {
            return ListenLensPushRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            return { ...ListenLensPushResponse.decode(data), toObject() { return this; } };
        }
    },
};
export class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata || this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata,
                transport: this.options.transport,
                debug: this.options.debug,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message);
                    }
                    else {
                        const err = new Error(response.statusMessage);
                        err.code = response.status;
                        err.metadata = response.trailers;
                        reject(err);
                    }
                },
            });
        });
    }
    invoke(methodDesc, _request, metadata) {
        const upStreamCodes = [2, 4, 8, 9, 10, 13, 14, 15];
        const DEFAULT_TIMEOUT_TIME = 3000;
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata || this.options.metadata;
        return new Observable(observer => {
            const upStream = (() => {
                const client = grpc.invoke(methodDesc, {
                    host: this.host,
                    request,
                    transport: this.options.streamingTransport || this.options.transport,
                    metadata: maybeCombinedMetadata,
                    debug: this.options.debug,
                    onMessage: (next) => observer.next(next),
                    onEnd: (code, message) => {
                        if (code === 0) {
                            observer.complete();
                        }
                        else if (upStreamCodes.includes(code)) {
                            setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
                        }
                        else {
                            observer.error(new Error(`Error ${code} ${message}`));
                        }
                    },
                });
                observer.add(() => client.close());
            });
            upStream();
        }).pipe(share());
    }
}
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
