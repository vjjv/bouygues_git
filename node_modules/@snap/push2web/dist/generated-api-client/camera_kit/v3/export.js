import Long from "long";
import _m0 from "protobufjs/minimal";
import { Lens } from "./lens";
export const protobufPackage = "com.snap.camerakit.v3";
export var ExportLensesByIdRequest_Context_Extension_Name;
(function (ExportLensesByIdRequest_Context_Extension_Name) {
    ExportLensesByIdRequest_Context_Extension_Name["UNSET"] = "UNSET";
    ExportLensesByIdRequest_Context_Extension_Name["SHOP_KIT"] = "SHOP_KIT";
    ExportLensesByIdRequest_Context_Extension_Name["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdRequest_Context_Extension_Name || (ExportLensesByIdRequest_Context_Extension_Name = {}));
export function exportLensesByIdRequest_Context_Extension_NameFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return ExportLensesByIdRequest_Context_Extension_Name.UNSET;
        case 1:
        case "SHOP_KIT":
            return ExportLensesByIdRequest_Context_Extension_Name.SHOP_KIT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ExportLensesByIdRequest_Context_Extension_Name.UNRECOGNIZED;
    }
}
export function exportLensesByIdRequest_Context_Extension_NameToJSON(object) {
    switch (object) {
        case ExportLensesByIdRequest_Context_Extension_Name.UNSET:
            return "UNSET";
        case ExportLensesByIdRequest_Context_Extension_Name.SHOP_KIT:
            return "SHOP_KIT";
        default:
            return "UNKNOWN";
    }
}
export function exportLensesByIdRequest_Context_Extension_NameToNumber(object) {
    switch (object) {
        case ExportLensesByIdRequest_Context_Extension_Name.UNSET:
            return 0;
        case ExportLensesByIdRequest_Context_Extension_Name.SHOP_KIT:
            return 1;
        default:
            return 0;
    }
}
export var ExportLensesByIdResponse_ExcludedLens_Code;
(function (ExportLensesByIdResponse_ExcludedLens_Code) {
    ExportLensesByIdResponse_ExcludedLens_Code["UNSET"] = "UNSET";
    ExportLensesByIdResponse_ExcludedLens_Code["UNKNOWN"] = "UNKNOWN";
    ExportLensesByIdResponse_ExcludedLens_Code["NOT_FOUND"] = "NOT_FOUND";
    ExportLensesByIdResponse_ExcludedLens_Code["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
    ExportLensesByIdResponse_ExcludedLens_Code["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
    ExportLensesByIdResponse_ExcludedLens_Code["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
    ExportLensesByIdResponse_ExcludedLens_Code["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdResponse_ExcludedLens_Code || (ExportLensesByIdResponse_ExcludedLens_Code = {}));
export function exportLensesByIdResponse_ExcludedLens_CodeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSET":
            return ExportLensesByIdResponse_ExcludedLens_Code.UNSET;
        case 1:
        case "UNKNOWN":
            return ExportLensesByIdResponse_ExcludedLens_Code.UNKNOWN;
        case 2:
        case "NOT_FOUND":
            return ExportLensesByIdResponse_ExcludedLens_Code.NOT_FOUND;
        case 3:
        case "INCOMPATIBLE_LENS_CORE_VERSION":
            return ExportLensesByIdResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION;
        case 4:
        case "ARCHIVED_OR_INVISIBLE":
            return ExportLensesByIdResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE;
        case 5:
        case "CONTAINS_MUSIC":
            return ExportLensesByIdResponse_ExcludedLens_Code.CONTAINS_MUSIC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ExportLensesByIdResponse_ExcludedLens_Code.UNRECOGNIZED;
    }
}
export function exportLensesByIdResponse_ExcludedLens_CodeToJSON(object) {
    switch (object) {
        case ExportLensesByIdResponse_ExcludedLens_Code.UNSET:
            return "UNSET";
        case ExportLensesByIdResponse_ExcludedLens_Code.UNKNOWN:
            return "UNKNOWN";
        case ExportLensesByIdResponse_ExcludedLens_Code.NOT_FOUND:
            return "NOT_FOUND";
        case ExportLensesByIdResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
            return "INCOMPATIBLE_LENS_CORE_VERSION";
        case ExportLensesByIdResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
            return "ARCHIVED_OR_INVISIBLE";
        case ExportLensesByIdResponse_ExcludedLens_Code.CONTAINS_MUSIC:
            return "CONTAINS_MUSIC";
        default:
            return "UNKNOWN";
    }
}
export function exportLensesByIdResponse_ExcludedLens_CodeToNumber(object) {
    switch (object) {
        case ExportLensesByIdResponse_ExcludedLens_Code.UNSET:
            return 0;
        case ExportLensesByIdResponse_ExcludedLens_Code.UNKNOWN:
            return 1;
        case ExportLensesByIdResponse_ExcludedLens_Code.NOT_FOUND:
            return 2;
        case ExportLensesByIdResponse_ExcludedLens_Code.INCOMPATIBLE_LENS_CORE_VERSION:
            return 3;
        case ExportLensesByIdResponse_ExcludedLens_Code.ARCHIVED_OR_INVISIBLE:
            return 4;
        case ExportLensesByIdResponse_ExcludedLens_Code.CONTAINS_MUSIC:
            return 5;
        default:
            return 0;
    }
}
function createBaseExportLensesByIdRequest() {
    return { unlockableIds: [], context: undefined };
}
export const ExportLensesByIdRequest = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportLensesByIdRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.unlockableIds.push(longToNumber(reader.int64()));
                        }
                    }
                    else {
                        message.unlockableIds.push(longToNumber(reader.int64()));
                    }
                    break;
                case 2:
                    message.context = ExportLensesByIdRequest_Context.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            unlockableIds: Array.isArray(object?.unlockableIds) ? object.unlockableIds.map((e) => Number(e)) : [],
            context: isSet(object.context) ? ExportLensesByIdRequest_Context.fromJSON(object.context) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.unlockableIds) {
            obj.unlockableIds = message.unlockableIds.map((e) => Math.round(e));
        }
        else {
            obj.unlockableIds = [];
        }
        message.context !== undefined &&
            (obj.context = message.context ? ExportLensesByIdRequest_Context.toJSON(message.context) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExportLensesByIdRequest();
        message.unlockableIds = object.unlockableIds?.map((e) => e) || [];
        message.context =
            object.context !== undefined && object.context !== null
                ? ExportLensesByIdRequest_Context.fromPartial(object.context)
                : undefined;
        return message;
    },
};
function createBaseExportLensesByIdRequest_Context() {
    return {
        userAgent: "",
        locale: "",
        extention: undefined,
        extension: undefined,
        extensionRequestContext: new Uint8Array(),
    };
}
export const ExportLensesByIdRequest_Context = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportLensesByIdRequest_Context();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userAgent = reader.string();
                    break;
                case 2:
                    message.locale = reader.string();
                    break;
                case 3:
                    message.extention = ExportLensesByIdRequest_Context_Extension.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.extension = ExportLensesByIdRequest_Context_Extension.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.extensionRequestContext = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userAgent: isSet(object.userAgent) ? String(object.userAgent) : "",
            locale: isSet(object.locale) ? String(object.locale) : "",
            extention: isSet(object.extention)
                ? ExportLensesByIdRequest_Context_Extension.fromJSON(object.extention)
                : undefined,
            extension: isSet(object.extension)
                ? ExportLensesByIdRequest_Context_Extension.fromJSON(object.extension)
                : undefined,
            extensionRequestContext: isSet(object.extensionRequestContext)
                ? bytesFromBase64(object.extensionRequestContext)
                : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.userAgent !== undefined && (obj.userAgent = message.userAgent);
        message.locale !== undefined && (obj.locale = message.locale);
        message.extention !== undefined &&
            (obj.extention = message.extention
                ? ExportLensesByIdRequest_Context_Extension.toJSON(message.extention)
                : undefined);
        message.extension !== undefined &&
            (obj.extension = message.extension
                ? ExportLensesByIdRequest_Context_Extension.toJSON(message.extension)
                : undefined);
        message.extensionRequestContext !== undefined &&
            (obj.extensionRequestContext = base64FromBytes(message.extensionRequestContext !== undefined ? message.extensionRequestContext : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExportLensesByIdRequest_Context();
        message.userAgent = object.userAgent ?? "";
        message.locale = object.locale ?? "";
        message.extention =
            object.extention !== undefined && object.extention !== null
                ? ExportLensesByIdRequest_Context_Extension.fromPartial(object.extention)
                : undefined;
        message.extension =
            object.extension !== undefined && object.extension !== null
                ? ExportLensesByIdRequest_Context_Extension.fromPartial(object.extension)
                : undefined;
        message.extensionRequestContext = object.extensionRequestContext ?? new Uint8Array();
        return message;
    },
};
function createBaseExportLensesByIdRequest_Context_Extension() {
    return { name: ExportLensesByIdRequest_Context_Extension_Name.UNSET, version: "" };
}
export const ExportLensesByIdRequest_Context_Extension = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportLensesByIdRequest_Context_Extension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = exportLensesByIdRequest_Context_Extension_NameFromJSON(reader.int32());
                    break;
                case 2:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name)
                ? exportLensesByIdRequest_Context_Extension_NameFromJSON(object.name)
                : ExportLensesByIdRequest_Context_Extension_Name.UNSET,
            version: isSet(object.version) ? String(object.version) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = exportLensesByIdRequest_Context_Extension_NameToJSON(message.name));
        message.version !== undefined && (obj.version = message.version);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExportLensesByIdRequest_Context_Extension();
        message.name = object.name ?? ExportLensesByIdRequest_Context_Extension_Name.UNSET;
        message.version = object.version ?? "";
        return message;
    },
};
function createBaseExportLensesByIdResponse() {
    return { lenses: {}, excludedLenses: [] };
}
export const ExportLensesByIdResponse = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportLensesByIdResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = ExportLensesByIdResponse_LensesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.lenses[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.excludedLenses.push(ExportLensesByIdResponse_ExcludedLens.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            lenses: isObject(object.lenses)
                ? Object.entries(object.lenses).reduce((acc, [key, value]) => {
                    acc[Number(key)] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
            excludedLenses: Array.isArray(object?.excludedLenses)
                ? object.excludedLenses.map((e) => ExportLensesByIdResponse_ExcludedLens.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        obj.lenses = {};
        if (message.lenses) {
            Object.entries(message.lenses).forEach(([k, v]) => {
                obj.lenses[k] = base64FromBytes(v);
            });
        }
        if (message.excludedLenses) {
            obj.excludedLenses = message.excludedLenses.map((e) => e ? ExportLensesByIdResponse_ExcludedLens.toJSON(e) : undefined);
        }
        else {
            obj.excludedLenses = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExportLensesByIdResponse();
        message.lenses = Object.entries(object.lenses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[Number(key)] = value;
            }
            return acc;
        }, {});
        message.excludedLenses =
            object.excludedLenses?.map((e) => ExportLensesByIdResponse_ExcludedLens.fromPartial(e)) || [];
        return message;
    },
};
function createBaseExportLensesByIdResponse_LensesEntry() {
    return { key: 0, value: new Uint8Array() };
}
export const ExportLensesByIdResponse_LensesEntry = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportLensesByIdResponse_LensesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = longToNumber(reader.int64());
                    break;
                case 2:
                    message.value = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined &&
            (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExportLensesByIdResponse_LensesEntry();
        message.key = object.key ?? 0;
        message.value = object.value ?? new Uint8Array();
        return message;
    },
};
function createBaseExportLensesByIdResponse_ExcludedLens() {
    return { lensId: 0, code: ExportLensesByIdResponse_ExcludedLens_Code.UNSET, reason: "" };
}
export const ExportLensesByIdResponse_ExcludedLens = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExportLensesByIdResponse_ExcludedLens();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lensId = longToNumber(reader.int64());
                    break;
                case 2:
                    message.code = exportLensesByIdResponse_ExcludedLens_CodeFromJSON(reader.int32());
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            lensId: isSet(object.lensId) ? Number(object.lensId) : 0,
            code: isSet(object.code)
                ? exportLensesByIdResponse_ExcludedLens_CodeFromJSON(object.code)
                : ExportLensesByIdResponse_ExcludedLens_Code.UNSET,
            reason: isSet(object.reason) ? String(object.reason) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.lensId !== undefined && (obj.lensId = Math.round(message.lensId));
        message.code !== undefined && (obj.code = exportLensesByIdResponse_ExcludedLens_CodeToJSON(message.code));
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExportLensesByIdResponse_ExcludedLens();
        message.lensId = object.lensId ?? 0;
        message.code = object.code ?? ExportLensesByIdResponse_ExcludedLens_Code.UNSET;
        message.reason = object.reason ?? "";
        return message;
    },
};
function createBaseExtensionRequestContext() {
    return { userAgent: "", locale: "" };
}
export const ExtensionRequestContext = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtensionRequestContext();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userAgent = reader.string();
                    break;
                case 2:
                    message.locale = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            userAgent: isSet(object.userAgent) ? String(object.userAgent) : "",
            locale: isSet(object.locale) ? String(object.locale) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.userAgent !== undefined && (obj.userAgent = message.userAgent);
        message.locale !== undefined && (obj.locale = message.locale);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseExtensionRequestContext();
        message.userAgent = object.userAgent ?? "";
        message.locale = object.locale ?? "";
        return message;
    },
};
function createBaseEnvelope() {
    return { lenses: [] };
}
export const Envelope = {
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEnvelope();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lenses.push(Lens.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            lenses: Array.isArray(object?.lenses) ? object.lenses.map((e) => Lens.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.lenses) {
            obj.lenses = message.lenses.map((e) => (e ? Lens.toJSON(e) : undefined));
        }
        else {
            obj.lenses = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = createBaseEnvelope();
        message.lenses = object.lenses?.map((e) => Lens.fromPartial(e)) || [];
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
